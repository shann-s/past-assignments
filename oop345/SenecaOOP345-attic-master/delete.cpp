// operator delete[] example
#include <iostream>      // std::cout
#include <exception>     // std::exception
#include <csignal>       // catch delete generated SIGABRT signal
#include <csetjmp>       // jmp_buf jb;/if(setjmp(jb) == 0)/longjmp(jb, val);
#include <functional>    // std::function

struct MyClass {
  uint8_t buf[0x10000];
  MyClass() {std::cout  << (void*) this << " MyClass constructed\n";}
  ~MyClass() {std::cout << (void*) this << " MyClass destroyed\n";}
};

jmp_buf jb;  // lambda compiler error if not global, warning if it is global.
// warning: capture of variable ‘jb’ with non-automatic storage duration
int main () {

  try {
    MyClass* ptr;
    std::cout << "ptr = new MyClass[3];\n";
    ptr = new MyClass[3];
    std::cout << (void*) ptr << " <- ptr\n\n";
    std::cout << "Call proper 'delete [] ptr'\n";
    delete[] ptr;
    std::cout << "\n";

    std::cout << "ptr = new MyClass[3];\n";
    ptr = new MyClass[3];
    std::cout << (void*) ptr << " <- ptr\n\n";

    signal(SIGABRT, [jb] (int sig) {std::cout << "signal callback: sig=" << sig << " (SIGABRT)\n"; longjmp(jb,sig);});
    if(setjmp(jb) == 0) {
      std::cout << "Call incorrect 'delete ptr'\n";
      delete ptr; // *** Error in `./delete': munmap_chunk(): invalid pointer: 0x0000000000d5ac28 ***
    } else {
      std::cout << "longjmp from SIGABRT signal handler - will try to continue execution\n";
      std::cout << "OK, delete aborted.  At this point, is the heap corrupt?\n";
      std::cout << "Note the first MyClass destructor was called.\n";
      std::cout << "Call proper 'delete [] ptr'\n";
      std::cout << "Will deleting the first MyClass instance a second time generate a double-delete error?";
      delete [] ptr;
      std::cout << "No, delete [] did not abort\n";
    }

    std::cout << "\n";
    std::cout << "The heap seems to be intact. Allocate and free some heap memory.\n";
    std::cout << "ptr = new MyClass[3];\n";
    ptr = new MyClass[3];
    std::cout << (void*) ptr << " <- ptr\n\n";
    std::cout << "Call proper 'delete [] ptr'\n";
    delete[] ptr;
    std::cout << "\n";

  } catch(std::exception& e) { // does not catch signals, such as SIGABRT generated by the delete function.
    std::cerr << "IT THREW: " << e.what() << "\n";
    return 1;
  }

  return 0;
}
